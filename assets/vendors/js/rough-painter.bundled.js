!function(){"use strict";function t(t,s){return t.type===s}function s(t){const s=t[0],e=t[1];return g(c(s[0]-e[0],2)+c(s[1]-e[1],2))}function e(t,s){const e=[],i=new P([t[0],t[1]],[t[2],t[3]]);for(let t=0;t<s.length;t++){const h=new P(s[t],s[(t+1)%s.length]);i.intersects(h)&&e.push([i.xi,i.yi])}return e}function i(t,s,e,i,h,n,o){return[-e*n-i*h+e+n*t+h*s,o*(e*h-i*n)+i+-o*h*t+o*n*s]}function h(t,s){const i=[];if(t&&t.length){let h=t[0][0],n=t[0][0],o=t[0][1],f=t[0][1];for(let s=1;s<t.length;s++)h=l(h,t[s][0]),n=a(n,t[s][0]),o=l(o,t[s][1]),f=a(f,t[s][1]);const c=s.hachureAngle;let p=s.hachureGap;0>p&&(p=4*s.strokeWidth),p=a(p,.1);const g=c%180*(y/180),_=u(g),x=d(g),O=r(g),b=new v(o-1,f+1,h-1,n+1,p,x,_,O);for(let s;null!=(s=b.nextLine());){const h=e(s,t);for(let t=0;t<h.length;t++)if(t<h.length-1){const s=h[t],e=h[t+1];i.push([s,e])}}}return i}function n(t,s,e,h,n,o){const a=[];let l=_(e/2),f=_(h/2);l+=o.getOffset(.05*-l,.05*l,n),f+=o.getOffset(.05*-f,.05*f,n);const c=n.hachureAngle;let p=n.hachureGap;0>=p&&(p=4*n.strokeWidth);let u=n.fillWeight;0>u&&(u=n.strokeWidth/2);const d=r(c%180*(y/180)),x=f/l,O=g(x*d*x*d+1),b=x*d/O,m=1/O,k=p/(l*f/g(f*m*(f*m)+l*b*(l*b))/l);let P=g(l*l-(t-l+k)*(t-l+k));for(let e=t-l+k;e<t+l;e+=k){P=g(l*l-(t-e)*(t-e));const h=i(e,s-P,t,s,b,m,x),n=i(e,s+P,t,s,b,m,x);a.push([h,n])}return a}function o(t,s){let e=s.fillStyle||"hachure";if(!M[e])switch(e){case"zigzag":M[e]||(M[e]=new w(t));break;case"cross-hatch":M[e]||(M[e]=new S(t));break;case"dots":M[e]||(M[e]=new L(t));break;default:e="hachure",M[e]||(M[e]=new T(t))}return M[e]}var r=Math.tan,a=Math.max,l=Math.min,f=Number.MAX_VALUE,c=Math.pow,p=Math.ceil,g=Math.sqrt,u=Math.cos,d=Math.sin,_=Math.abs,y=Math.PI;const x={A:7,a:7,C:6,c:6,H:1,h:1,L:2,l:2,M:2,m:2,Q:4,q:4,S:4,s:4,T:4,t:2,V:1,v:1,Z:0,z:0};class O{constructor(t){this.COMMAND=0,this.NUMBER=1,this.EOD=2,this.segments=[],this.parseData(t),this.processPoints()}tokenize(t){const s=[];for(;""!==t;)if(t.match(/^([ \t\r\n,]+)/))t=t.substr(RegExp.$1.length);else if(t.match(/^([aAcChHlLmMqQsStTvVzZ])/))s[s.length]={type:this.COMMAND,text:RegExp.$1},t=t.substr(RegExp.$1.length);else{if(!t.match(/^(([-+]?[0-9]+(\.[0-9]*)?|[-+]?\.[0-9]+)([eE][-+]?[0-9]+)?)/))return console.error("Unrecognized segment command: "+t),[];s[s.length]={type:this.NUMBER,text:`${parseFloat(RegExp.$1)}`},t=t.substr(RegExp.$1.length)}return s[s.length]={type:this.EOD,text:""},s}parseData(s){const e=this.tokenize(s);let i=0,h=e[i],n="BOD";for(this.segments=[];!t(h,this.EOD);){let o;const r=[];if("BOD"!==n)t(h,this.NUMBER)?o=x[n]:(i++,o=x[h.text],n=h.text);else{if("M"!==h.text&&"m"!==h.text)return void this.parseData("M0,0"+s);i++,o=x[h.text],n=h.text}if(i+o<e.length){for(let s=i;s<i+o;s++){const i=e[s];if(!t(i,this.NUMBER))return void console.error("Parameter type is not a number: "+n+","+i.text);r[r.length]=+i.text}if("number"!=typeof x[n])return void console.error("Unsupported segment type: "+n);{const t={key:n,data:r};this.segments.push(t),i+=o,h=e[i],"M"===n&&(n="L"),"m"===n&&(n="l")}}else console.error("Path data ended before all parameters were found")}}get closed(){if(void 0===this._closed){this._closed=!1;for(const t of this.segments)"z"===t.key.toLowerCase()&&(this._closed=!0)}return this._closed}processPoints(){let t=null,s=[0,0];for(let e=0;e<this.segments.length;e++){const i=this.segments[e];switch(i.key){case"M":case"L":case"T":i.point=[i.data[0],i.data[1]];break;case"m":case"l":case"t":i.point=[i.data[0]+s[0],i.data[1]+s[1]];break;case"H":i.point=[i.data[0],s[1]];break;case"h":i.point=[i.data[0]+s[0],s[1]];break;case"V":i.point=[s[0],i.data[0]];break;case"v":i.point=[s[0],i.data[0]+s[1]];break;case"z":case"Z":t&&(i.point=[t[0],t[1]]);break;case"C":i.point=[i.data[4],i.data[5]];break;case"c":i.point=[i.data[4]+s[0],i.data[5]+s[1]];break;case"S":case"Q":i.point=[i.data[2],i.data[3]];break;case"s":case"q":i.point=[i.data[2]+s[0],i.data[3]+s[1]];break;case"A":i.point=[i.data[5],i.data[6]];break;case"a":i.point=[i.data[5]+s[0],i.data[6]+s[1]]}("m"===i.key||"M"===i.key)&&(t=null),i.point&&(s=i.point,!t&&(t=i.point)),("z"===i.key||"Z"===i.key)&&(t=null)}}}class b{constructor(t){this._position=[0,0],this._first=null,this.bezierReflectionPoint=null,this.quadReflectionPoint=null,this.parsed=new O(t)}get segments(){return this.parsed.segments}get closed(){return this.parsed.closed}get linearPoints(){if(!this._linearPoints){const t=[];let s=[];for(const e of this.parsed.segments){const i=e.key.toLowerCase();("m"===i||"z"===i)&&(s.length&&(t.push(s),s=[]),"z"===i)||e.point&&s.push(e.point)}s.length&&(t.push(s),s=[]),this._linearPoints=t}return this._linearPoints}get first(){return this._first}set first(t){this._first=t}setPosition(t,s){this._position=[t,s],this._first||(this._first=[t,s])}get position(){return this._position}get x(){return this._position[0]}get y(){return this._position[1]}}class m{constructor(t,s,e,i,h,n){if(this._segIndex=0,this._numSegs=0,this._rx=0,this._ry=0,this._sinPhi=0,this._cosPhi=0,this._C=[0,0],this._theta=0,this._delta=0,this._T=0,this._from=t,t[0]===s[0]&&t[1]===s[1])return;const o=y/180;this._rx=_(e[0]),this._ry=_(e[1]),this._sinPhi=d(i*o),this._cosPhi=u(i*o);const r=this._cosPhi*(t[0]-s[0])/2+this._sinPhi*(t[1]-s[1])/2,a=-this._sinPhi*(t[0]-s[0])/2+this._cosPhi*(t[1]-s[1])/2;let l=0;const f=this._rx*this._rx*this._ry*this._ry-this._rx*this._rx*a*a-this._ry*this._ry*r*r;if(0>f){const t=g(1-f/(this._rx*this._rx*this._ry*this._ry));this._rx*=t,this._ry*=t,l=0}else l=(h===n?-1:1)*g(f/(this._rx*this._rx*a*a+this._ry*this._ry*r*r));const c=l*this._rx*a/this._ry,x=-l*this._ry*r/this._rx;this._C=[0,0],this._C[0]=this._cosPhi*c-this._sinPhi*x+(t[0]+s[0])/2,this._C[1]=this._sinPhi*c+this._cosPhi*x+(t[1]+s[1])/2,this._theta=this.calculateVectorAngle(1,0,(r-c)/this._rx,(a-x)/this._ry);let O=this.calculateVectorAngle((r-c)/this._rx,(a-x)/this._ry,(-r-c)/this._rx,(-a-x)/this._ry);!n&&0<O?O-=2*y:n&&0>O&&(O+=2*y),this._numSegs=p(_(O/(y/2))),this._delta=O/this._numSegs,this._T=8/3*d(this._delta/4)*d(this._delta/4)/d(this._delta/2)}getNextSegment(){if(this._segIndex===this._numSegs)return null;const t=u(this._theta),s=d(this._theta),e=this._theta+this._delta,i=u(e),h=d(e),n=[this._cosPhi*this._rx*i-this._sinPhi*this._ry*h+this._C[0],this._sinPhi*this._rx*i+this._cosPhi*this._ry*h+this._C[1]],o=[this._from[0]+this._T*(-this._cosPhi*this._rx*s-this._sinPhi*this._ry*t),this._from[1]+this._T*(-this._sinPhi*this._rx*s+this._cosPhi*this._ry*t)],r=[n[0]+this._T*(this._cosPhi*this._rx*h+this._sinPhi*this._ry*i),n[1]+this._T*(this._sinPhi*this._rx*h-this._cosPhi*this._ry*i)];return this._theta=e,this._from=[n[0],n[1]],this._segIndex++,{cp1:o,cp2:r,to:n}}calculateVectorAngle(t,s,e,i){var h=Math.atan2;const n=h(s,t),o=h(i,e);return o>=n?o-n:2*y-(n-o)}}class k{constructor(t,s){this.sets=t,this.closed=s}fit(t){const s=[];for(const e of this.sets){const i=e.length;let h=Math.floor(t*i);if(5>h){if(5>=i)continue;h=5}s.push(this.reduce(e,h))}let e="";for(const t of s){for(let s=0;s<t.length;s++){const i=t[s];e+=0===s?"M"+i[0]+","+i[1]:"L"+i[0]+","+i[1]}this.closed&&(e+="z ")}return e}distance(t,s){return g(c(t[0]-s[0],2)+c(t[1]-s[1],2))}reduce(t,s){if(t.length<=s)return t;const e=t.slice(0);for(;e.length>s;){let t=-1,s=-1;for(let i=1;i<e.length-1;i++){const h=this.distance(e[i-1],e[i]),n=this.distance(e[i],e[i+1]),o=this.distance(e[i-1],e[i+1]),r=(h+n+o)/2,a=g(r*(r-h)*(r-n)*(r-o));(0>t||a<t)&&(t=a,s=i)}if(!(0<s))break;e.splice(s,1)}return e}}class P{constructor(t,s){this.xi=f,this.yi=f,this.px1=t[0],this.py1=t[1],this.px2=s[0],this.py2=s[1],this.a=this.py2-this.py1,this.b=this.px1-this.px2,this.c=this.px2*this.py1-this.px1*this.py2,this._undefined=0===this.a&&0===this.b&&0===this.c}isUndefined(){return this._undefined}intersects(t){if(this.isUndefined()||t.isUndefined())return!1;let s=f,e=f,i=0,h=0;const n=this.a,o=this.b,r=this.c;return 1e-5<_(o)&&(s=-n/o,i=-r/o),1e-5<_(t.b)&&(e=-t.a/t.b,h=-t.c/t.b),s===f?e===f?-r/n==-t.c/t.a&&(this.py1>=l(t.py1,t.py2)&&this.py1<=a(t.py1,t.py2)?(this.xi=this.px1,this.yi=this.py1,!0):!!(this.py2>=l(t.py1,t.py2)&&this.py2<=a(t.py1,t.py2))&&(this.xi=this.px2,this.yi=this.py2,!0)):(this.xi=this.px1,this.yi=e*this.xi+h,!(-1e-5>(this.py1-this.yi)*(this.yi-this.py2)||-1e-5>(t.py1-this.yi)*(this.yi-t.py2)||1e-5>_(t.a)&&-1e-5>(t.px1-this.xi)*(this.xi-t.px2))):e===f?(this.xi=t.px1,this.yi=s*this.xi+i,!(-1e-5>(t.py1-this.yi)*(this.yi-t.py2)||-1e-5>(this.py1-this.yi)*(this.yi-this.py2)||1e-5>_(n)&&-1e-5>(this.px1-this.xi)*(this.xi-this.px2))):s===e?i==h&&(this.px1>=l(t.px1,t.px2)&&this.px1<=a(t.py1,t.py2)?(this.xi=this.px1,this.yi=this.py1,!0):!!(this.px2>=l(t.px1,t.px2)&&this.px2<=a(t.px1,t.px2))&&(this.xi=this.px2,this.yi=this.py2,!0)):(this.xi=(h-i)/(s-e),this.yi=s*this.xi+i,!(-1e-5>(this.px1-this.xi)*(this.xi-this.px2)||-1e-5>(t.px1-this.xi)*(this.xi-t.px2)))}}class v{constructor(t,s,e,i,h,n,o,r){this.deltaX=0,this.hGap=0,this.top=t,this.bottom=s,this.left=e,this.right=i,this.gap=h,this.sinAngle=n,this.tanAngle=r,1e-4>_(n)?this.pos=e+h:.9999<_(n)?this.pos=t+h:(this.deltaX=(s-t)*_(r),this.pos=e-_(this.deltaX),this.hGap=_(h/o),this.sLeft=new P([e,s],[e,t]),this.sRight=new P([i,s],[i,t]))}nextLine(){if(1e-4>_(this.sinAngle)){if(this.pos<this.right){const t=[this.pos,this.top,this.pos,this.bottom];return this.pos+=this.gap,t}}else if(.9999<_(this.sinAngle)){if(this.pos<this.bottom){const t=[this.left,this.pos,this.right,this.pos];return this.pos+=this.gap,t}}else{let t=this.pos-this.deltaX/2,s=this.pos+this.deltaX/2,e=this.bottom,i=this.top;if(this.pos<this.right+this.deltaX){for(;t<this.left&&s<this.left||t>this.right&&s>this.right;)if(this.pos+=this.hGap,t=this.pos-this.deltaX/2,s=this.pos+this.deltaX/2,this.pos>this.right+this.deltaX)return null;const h=new P([t,e],[s,i]);this.sLeft&&h.intersects(this.sLeft)&&(t=h.xi,e=h.yi),this.sRight&&h.intersects(this.sRight)&&(s=h.xi,i=h.yi),0<this.tanAngle&&(t=this.right-(t-this.left),s=this.right-(s-this.left));const n=[t,e,s,i];return this.pos+=this.hGap,n}}return null}}class T{constructor(t){this.renderer=t}fillPolygon(t,s){return this._fillPolygon(t,s)}fillEllipse(t,s,e,i,h){return this._fillEllipse(t,s,e,i,h)}_fillPolygon(t,s,e=!1){const i=h(t,s);return{type:"fillSketch",ops:this.renderLines(i,s,e)}}_fillEllipse(t,s,e,i,h,o=!1){const r=n(t,s,e,i,h,this.renderer);return{type:"fillSketch",ops:this.renderLines(r,h,o)}}renderLines(t,s,e){let i=[],h=null;for(const n of t)i=i.concat(this.renderer.doubleLine(n[0][0],n[0][1],n[1][0],n[1][1],s)),e&&h&&(i=i.concat(this.renderer.doubleLine(h[0],h[1],n[0][0],n[0][1],s))),h=n[1];return i}}class w extends T{fillPolygon(t,s){return this._fillPolygon(t,s,!0)}fillEllipse(t,s,e,i,h){return this._fillEllipse(t,s,e,i,h,!0)}}class S extends T{fillPolygon(t,s){const e=this._fillPolygon(t,s),i=Object.assign({},s,{hachureAngle:s.hachureAngle+90}),h=this._fillPolygon(t,i);return e.ops=e.ops.concat(h.ops),e}fillEllipse(t,s,e,i,h){const n=this._fillEllipse(t,s,e,i,h),o=Object.assign({},h,{hachureAngle:h.hachureAngle+90}),r=this._fillEllipse(t,s,e,i,o);return n.ops=n.ops.concat(r.ops),n}}class L{constructor(t){this.renderer=t}fillPolygon(t,s){const e=h(t,s=Object.assign({},s,{curveStepCount:4,hachureAngle:0}));return this.dotsOnLines(e,s)}fillEllipse(t,s,e,i,h){const o=n(t,s,e,i,h=Object.assign({},h,{curveStepCount:4,hachureAngle:0}),this.renderer);return this.dotsOnLines(o,h)}dotsOnLines(t,e){let i=[],h=e.hachureGap;0>h&&(h=4*e.strokeWidth),h=a(h,.1);let n=e.fillWeight;0>n&&(n=e.strokeWidth/2);for(const o of t){const t=s(o),r=p(t/h)-1,a=Math.atan((o[1][1]-o[0][1])/(o[1][0]-o[0][0]));for(let t=0;t<r;t++){const s=h*(t+1),r=s*d(a),l=s*u(a),f=[o[0][0]-l,o[0][1]+r],c=this.renderer.getOffset(f[0]-h/4,f[0]+h/4,e),p=this.renderer.getOffset(f[1]-h/4,f[1]+h/4,e),g=this.renderer.ellipse(c,p,n,n,e);i=i.concat(g.ops)}}return{type:"fillSketch",ops:i}}}const M={};class R{line(t,s,e,i,h){return{type:"path",ops:this.doubleLine(t,s,e,i,h)}}linearPath(t,s,e){const i=(t||[]).length;if(2<i){let h=[];for(let s=0;s<i-1;s++)h=h.concat(this.doubleLine(t[s][0],t[s][1],t[s+1][0],t[s+1][1],e));return s&&(h=h.concat(this.doubleLine(t[i-1][0],t[i-1][1],t[0][0],t[0][1],e))),{type:"path",ops:h}}return 2===i?this.line(t[0][0],t[0][1],t[1][0],t[1][1],e):{type:"path",ops:[]}}polygon(t,s){return this.linearPath(t,!0,s)}rectangle(t,s,e,i,h){return this.polygon([[t,s],[t+e,s],[t+e,s+i],[t,s+i]],h)}curve(t,s){const e=this._curveWithOffset(t,1*(1+.2*s.roughness),s),i=this._curveWithOffset(t,1.5*(1+.22*s.roughness),s);return{type:"path",ops:e.concat(i)}}ellipse(t,s,e,i,h){const n=2*y/h.curveStepCount;let o=_(e/2),r=_(i/2);o+=this.getOffset(.05*-o,.05*o,h),r+=this.getOffset(.05*-r,.05*r,h);const a=this._ellipse(n,t,s,o,r,1,n*this.getOffset(.1,this.getOffset(.4,1,h),h),h),l=this._ellipse(n,t,s,o,r,1.5,0,h);return{type:"path",ops:a.concat(l)}}arc(t,s,e,i,h,n,o,r,a){const f=t,c=s;let p=_(e/2),g=_(i/2);p+=this.getOffset(.01*-p,.01*p,a),g+=this.getOffset(.01*-g,.01*g,a);let x=h,O=n;for(;0>x;)x+=2*y,O+=2*y;O-x>2*y&&(x=0,O=2*y);const b=2*y/a.curveStepCount,m=l(b/2,(O-x)/2),k=this._arc(m,f,c,p,g,x,O,1,a),P=this._arc(m,f,c,p,g,x,O,1.5,a);let v=k.concat(P);return o&&(r?(v=v.concat(this.doubleLine(f,c,f+p*u(x),c+g*d(x),a)),v=v.concat(this.doubleLine(f,c,f+p*u(O),c+g*d(O),a))):(v.push({op:"lineTo",data:[f,c]}),v.push({op:"lineTo",data:[f+p*u(x),c+g*d(x)]}))),{type:"path",ops:v}}svgPath(t,s){t=(t||"").replace(/\n/g," ").replace(/(-\s)/g,"-").replace("/(ss)/g"," ");let e=new b(t);if(s.simplification){const t=new k(e.linearPoints,e.closed).fit(s.simplification);e=new b(t)}let i=[];const h=e.segments||[];for(let t=0;t<h.length;t++){const n=h[t],o=0<t?h[t-1]:null,r=this._processSegment(e,n,o,s);r&&r.length&&(i=i.concat(r))}return{type:"path",ops:i}}solidFillPolygon(t,s){const e=[];if(t.length){const i=s.maxRandomnessOffset||0,h=t.length;if(2<h){e.push({op:"move",data:[t[0][0]+this.getOffset(-i,i,s),t[0][1]+this.getOffset(-i,i,s)]});for(let n=1;n<h;n++)e.push({op:"lineTo",data:[t[n][0]+this.getOffset(-i,i,s),t[n][1]+this.getOffset(-i,i,s)]})}}return{type:"fillPath",ops:e}}patternFillPolygon(t,s){return o(this,s).fillPolygon(t,s)}patternFillEllipse(t,s,e,i,h){return o(this,h).fillEllipse(t,s,e,i,h)}patternFillArc(t,s,e,i,h,n,o){const r=t,a=s;let l=_(e/2),f=_(i/2);l+=this.getOffset(.01*-l,.01*l,o),f+=this.getOffset(.01*-f,.01*f,o);let c=h,p=n;for(;0>c;)c+=2*y,p+=2*y;p-c>2*y&&(c=0,p=2*y);const g=(p-c)/o.curveStepCount,x=[];for(let t=c;t<=p;t+=g)x.push([r+l*u(t),a+f*d(t)]);return x.push([r+l*u(p),a+f*d(p)]),x.push([r,a]),this.patternFillPolygon(x,o)}getOffset(t,s,e){return e.roughness*(Math.random()*(s-t)+t)}doubleLine(t,s,e,i,h){const n=this._line(t,s,e,i,h,!0,!1),o=this._line(t,s,e,i,h,!0,!0);return n.concat(o)}_line(t,s,e,i,h,n,o){const r=c(t-e,2)+c(s-i,2);let a=h.maxRandomnessOffset||0;a*a*100>r&&(a=g(r)/10);const l=a/2,f=.2+.2*Math.random();let p=h.bowing*h.maxRandomnessOffset*(i-s)/200,u=h.bowing*h.maxRandomnessOffset*(t-e)/200;p=this.getOffset(-p,p,h),u=this.getOffset(-u,u,h);const d=[];return n&&(o?d.push({op:"move",data:[t+this.getOffset(-l,l,h),s+this.getOffset(-l,l,h)]}):d.push({op:"move",data:[t+this.getOffset(-a,a,h),s+this.getOffset(-a,a,h)]})),o?d.push({op:"bcurveTo",data:[p+t+(e-t)*f+this.getOffset(-l,l,h),u+s+(i-s)*f+this.getOffset(-l,l,h),p+t+2*(e-t)*f+this.getOffset(-l,l,h),u+s+2*(i-s)*f+this.getOffset(-l,l,h),e+this.getOffset(-l,l,h),i+this.getOffset(-l,l,h)]}):d.push({op:"bcurveTo",data:[p+t+(e-t)*f+this.getOffset(-a,a,h),u+s+(i-s)*f+this.getOffset(-a,a,h),p+t+2*(e-t)*f+this.getOffset(-a,a,h),u+s+2*(i-s)*f+this.getOffset(-a,a,h),e+this.getOffset(-a,a,h),i+this.getOffset(-a,a,h)]}),d}_curve(t,s,e){const i=t.length;let h=[];if(3<i){const n=[],o=1-e.curveTightness;h.push({op:"move",data:[t[1][0],t[1][1]]});for(let s=1;s+2<i;s++){const e=t[s];n[0]=[e[0],e[1]],n[1]=[e[0]+(o*t[s+1][0]-o*t[s-1][0])/6,e[1]+(o*t[s+1][1]-o*t[s-1][1])/6],n[2]=[t[s+1][0]+(o*t[s][0]-o*t[s+2][0])/6,t[s+1][1]+(o*t[s][1]-o*t[s+2][1])/6],n[3]=[t[s+1][0],t[s+1][1]],h.push({op:"bcurveTo",data:[n[1][0],n[1][1],n[2][0],n[2][1],n[3][0],n[3][1]]})}if(s&&2===s.length){const t=e.maxRandomnessOffset;h.push({op:"lineTo",data:[s[0]+this.getOffset(-t,t,e),s[1]+ +this.getOffset(-t,t,e)]})}}else 3===i?(h.push({op:"move",data:[t[1][0],t[1][1]]}),h.push({op:"bcurveTo",data:[t[1][0],t[1][1],t[2][0],t[2][1],t[2][0],t[2][1]]})):2===i&&(h=h.concat(this.doubleLine(t[0][0],t[0][1],t[1][0],t[1][1],e)));return h}_ellipse(t,s,e,i,h,n,o,r){const a=this.getOffset(-.5,.5,r)-y/2,l=[];l.push([this.getOffset(-n,n,r)+s+.9*i*u(a-t),this.getOffset(-n,n,r)+e+.9*h*d(a-t)]);for(let o=a;o<2*y+a-.01;o+=t)l.push([this.getOffset(-n,n,r)+s+i*u(o),this.getOffset(-n,n,r)+e+h*d(o)]);return l.push([this.getOffset(-n,n,r)+s+i*u(a+2*y+.5*o),this.getOffset(-n,n,r)+e+h*d(a+2*y+.5*o)]),l.push([this.getOffset(-n,n,r)+s+.98*i*u(a+o),this.getOffset(-n,n,r)+e+.98*h*d(a+o)]),l.push([this.getOffset(-n,n,r)+s+.9*i*u(a+.5*o),this.getOffset(-n,n,r)+e+.9*h*d(a+.5*o)]),this._curve(l,null,r)}_curveWithOffset(t,s,e){const i=[[t[0][0]+this.getOffset(-s,s,e),t[0][1]+this.getOffset(-s,s,e)],[t[0][0]+this.getOffset(-s,s,e),t[0][1]+this.getOffset(-s,s,e)]];for(let h=1;h<t.length;h++)i.push([t[h][0]+this.getOffset(-s,s,e),t[h][1]+this.getOffset(-s,s,e)]),h===t.length-1&&i.push([t[h][0]+this.getOffset(-s,s,e),t[h][1]+this.getOffset(-s,s,e)]);return this._curve(i,null,e)}_arc(t,s,e,i,h,n,o,r,a){const l=n+this.getOffset(-.1,.1,a),f=[];f.push([this.getOffset(-r,r,a)+s+.9*i*u(l-t),this.getOffset(-r,r,a)+e+.9*h*d(l-t)]);for(let n=l;n<=o;n+=t)f.push([this.getOffset(-r,r,a)+s+i*u(n),this.getOffset(-r,r,a)+e+h*d(n)]);return f.push([s+i*u(o),e+h*d(o)]),f.push([s+i*u(o),e+h*d(o)]),this._curve(f,null,a)}_bezierTo(t,s,e,i,h,n,o,r){const a=[],l=[r.maxRandomnessOffset||1,(r.maxRandomnessOffset||1)+.5];let f=[0,0];for(let c=0;2>c;c++)0===c?a.push({op:"move",data:[o.x,o.y]}):a.push({op:"move",data:[o.x+this.getOffset(-l[0],l[0],r),o.y+this.getOffset(-l[0],l[0],r)]}),f=[h+this.getOffset(-l[c],l[c],r),n+this.getOffset(-l[c],l[c],r)],a.push({op:"bcurveTo",data:[t+this.getOffset(-l[c],l[c],r),s+this.getOffset(-l[c],l[c],r),e+this.getOffset(-l[c],l[c],r),i+this.getOffset(-l[c],l[c],r),f[0],f[1]]});return o.setPosition(f[0],f[1]),a}_processSegment(t,s,e,i){let h=[];switch(s.key){case"M":case"m":{const e="m"===s.key;if(2<=s.data.length){let n=+s.data[0],o=+s.data[1];e&&(n+=t.x,o+=t.y);const r=1*(i.maxRandomnessOffset||0);n+=this.getOffset(-r,r,i),o+=this.getOffset(-r,r,i),t.setPosition(n,o),h.push({op:"move",data:[n,o]})}break}case"L":case"l":{const e="l"===s.key;if(2<=s.data.length){let n=+s.data[0],o=+s.data[1];e&&(n+=t.x,o+=t.y),h=h.concat(this.doubleLine(t.x,t.y,n,o,i)),t.setPosition(n,o)}break}case"H":case"h":{const e="h"===s.key;if(s.data.length){let n=+s.data[0];e&&(n+=t.x),h=h.concat(this.doubleLine(t.x,t.y,n,t.y,i)),t.setPosition(n,t.y)}break}case"V":case"v":{const e="v"===s.key;if(s.data.length){let n=+s.data[0];e&&(n+=t.y),h=h.concat(this.doubleLine(t.x,t.y,t.x,n,i)),t.setPosition(t.x,n)}break}case"Z":case"z":t.first&&(h=h.concat(this.doubleLine(t.x,t.y,t.first[0],t.first[1],i)),t.setPosition(t.first[0],t.first[1]),t.first=null);break;case"C":case"c":{const e="c"===s.key;if(6<=s.data.length){let n=+s.data[0],o=+s.data[1],r=+s.data[2],a=+s.data[3],l=+s.data[4],f=+s.data[5];e&&(n+=t.x,r+=t.x,l+=t.x,o+=t.y,a+=t.y,f+=t.y);const c=this._bezierTo(n,o,r,a,l,f,t,i);h=h.concat(c),t.bezierReflectionPoint=[l+(l-r),f+(f-a)]}break}case"S":case"s":{const n="s"===s.key;if(4<=s.data.length){let o=+s.data[0],r=+s.data[1],a=+s.data[2],l=+s.data[3];n&&(o+=t.x,a+=t.x,r+=t.y,l+=t.y);let f=o,c=r;const p=e?e.key:"";let g=null;("c"===p||"C"===p||"s"===p||"S"===p)&&(g=t.bezierReflectionPoint),g&&(f=g[0],c=g[1]);const u=this._bezierTo(f,c,o,r,a,l,t,i);h=h.concat(u),t.bezierReflectionPoint=[a+(a-o),l+(l-r)]}break}case"Q":case"q":{const e="q"===s.key;if(4<=s.data.length){let n=+s.data[0],o=+s.data[1],r=+s.data[2],a=+s.data[3];e&&(n+=t.x,r+=t.x,o+=t.y,a+=t.y);const l=1*(1+.2*i.roughness),f=1.5*(1+.22*i.roughness);h.push({op:"move",data:[t.x+this.getOffset(-l,l,i),t.y+this.getOffset(-l,l,i)]});let c=[r+this.getOffset(-l,l,i),a+this.getOffset(-l,l,i)];h.push({op:"qcurveTo",data:[n+this.getOffset(-l,l,i),o+this.getOffset(-l,l,i),c[0],c[1]]}),h.push({op:"move",data:[t.x+this.getOffset(-f,f,i),t.y+this.getOffset(-f,f,i)]}),c=[r+this.getOffset(-f,f,i),a+this.getOffset(-f,f,i)],h.push({op:"qcurveTo",data:[n+this.getOffset(-f,f,i),o+this.getOffset(-f,f,i),c[0],c[1]]}),t.setPosition(c[0],c[1]),t.quadReflectionPoint=[r+(r-n),a+(a-o)]}break}case"T":case"t":{const n="t"===s.key;if(2<=s.data.length){let o=+s.data[0],r=+s.data[1];n&&(o+=t.x,r+=t.y);let a=o,l=r;const f=e?e.key:"";let c=null;("q"===f||"Q"===f||"t"===f||"T"===f)&&(c=t.quadReflectionPoint),c&&(a=c[0],l=c[1]);const p=1*(1+.2*i.roughness),g=1.5*(1+.22*i.roughness);h.push({op:"move",data:[t.x+this.getOffset(-p,p,i),t.y+this.getOffset(-p,p,i)]});let u=[o+this.getOffset(-p,p,i),r+this.getOffset(-p,p,i)];h.push({op:"qcurveTo",data:[a+this.getOffset(-p,p,i),l+this.getOffset(-p,p,i),u[0],u[1]]}),h.push({op:"move",data:[t.x+this.getOffset(-g,g,i),t.y+this.getOffset(-g,g,i)]}),u=[o+this.getOffset(-g,g,i),r+this.getOffset(-g,g,i)],h.push({op:"qcurveTo",data:[a+this.getOffset(-g,g,i),l+this.getOffset(-g,g,i),u[0],u[1]]}),t.setPosition(u[0],u[1]),t.quadReflectionPoint=[o+(o-a),r+(r-l)]}break}case"A":case"a":{const e="a"===s.key;if(7<=s.data.length){const n=+s.data[0],o=+s.data[1],r=+s.data[2],a=+s.data[3],l=+s.data[4];let f=+s.data[5],c=+s.data[6];if(e&&(f+=t.x,c+=t.y),f===t.x&&c===t.y)break;if(0==n||0==o)h=h.concat(this.doubleLine(t.x,t.y,f,c,i)),t.setPosition(f,c);else for(let s=0;1>s;s++){const s=new m([t.x,t.y],[f,c],[n,o],r,!!a,!!l);for(let e=s.getNextSegment();e;){const n=this._bezierTo(e.cp1[0],e.cp1[1],e.cp2[0],e.cp2[1],e.to[0],e.to[1],t,i);h=h.concat(n),e=s.getNextSegment()}}}break}}return h}}registerPaint("rough-painter",class{static get inputProperties(){return["--rough-fill","--rough-fill-style","--rough-roughness","--rough-hachure-gap","--rough-hachure-angle","--rough-fill-weight","--rough-border-color","--rough-border-width"]}constructor(){this.renderer=new R,this.defaultOptions={maxRandomnessOffset:2,roughness:1,bowing:1,stroke:"#000",strokeWidth:1,curveTightness:0,curveStepCount:9,fill:null,fillStyle:"hachure",fillWeight:-1,hachureAngle:-41,hachureGap:-1}}_setFloatOption(t,s,e,i){t.get(s).length&&(i[e]=parseFloat(t.get(s).toString().trim()))}_setStringOption(t,s,e,i){t.get(s).length&&(i[e]=t.get(s).toString().trim())}paint(t,s,e){const i={};this._setFloatOption(e,"--rough-roughness","roughness",i),this._setFloatOption(e,"--rough-hachure-gap","hachureGap",i),this._setFloatOption(e,"--rough-hachure-angle","hachureAngle",i),this._setFloatOption(e,"--rough-fill-weight","fillWeight",i),this._setFloatOption(e,"--rough-border-width","strokeWidth",i),this._setStringOption(e,"--rough-fill-style","fillStyle",i),this._setStringOption(e,"--rough-fill","fill",i),this._setStringOption(e,"--rough-border-color","stroke",i);const h=Object.assign({},this.defaultOptions,i),n=i.strokeWidth||0,o=[[0+n,0+n],[s.width-n,0+n],[s.width-n,s.height-n],[0+n,s.height-n]],r=[];i.fill&&("solid"===h.fillStyle?r.push(this.renderer.solidFillPolygon(o,h)):r.push(this.renderer.patternFillPolygon(o,h))),i.strokeWidth&&0<i.strokeWidth&&r.push(this.renderer.polygon(o,h)),this._drawOps(r,h,t)}_drawOps(t,s,e){for(const i of t)switch(i.type){case"path":e.save(),e.strokeStyle=s.stroke,e.lineWidth=s.strokeWidth,this._drawToContext(e,i),e.restore();break;case"fillPath":e.save(),e.fillStyle=s.fill||"",this._drawToContext(e,i),e.restore();break;case"fillSketch":this._fillSketch(e,i,s)}}_fillSketch(t,s,e){let i=e.fillWeight;0>i&&(i=e.strokeWidth/2),t.save(),t.strokeStyle=e.fill||"",t.lineWidth=i,this._drawToContext(t,s),t.restore()}_drawToContext(t,s){t.beginPath();for(const e of s.ops){const s=e.data;switch(e.op){case"move":t.moveTo(s[0],s[1]);break;case"bcurveTo":t.bezierCurveTo(s[0],s[1],s[2],s[3],s[4],s[5]);break;case"qcurveTo":t.quadraticCurveTo(s[0],s[1],s[2],s[3]);break;case"lineTo":t.lineTo(s[0],s[1])}}"fillPath"===s.type?t.fill():t.stroke()}})}();